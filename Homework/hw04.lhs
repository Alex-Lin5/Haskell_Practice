
--------------------------------------------------------------------------------

CIS 623 Structured programming and formal methods

Fall 2022

Homework 04 

Introduction to program testing
Representing ACL formulas and implement their evaluation functions (Part I)
Higher order functions

-------------------------------------------------------------------------------

> import Prelude 
> import Set
> import Test.QuickCheck

Total points: 10 + 5 + 30 + 30 + 55 + 20 = 150


-------------------------------------------------------------------------------


(10 point) Fill in the following information. You will lose 3 point for each 
missing or incorrect answer.

Name:

Email:

Number:

ie. The 3 digit number assigned to you

-------------------------------------------------------------------------------

Due date:

Release:        Nov 01, 2022 
Due date:       Nov 08, 2022, 11:59 pm

Remarks:

1. (5 point) You submission should be named as XXX-hw04.lhs where XXX is the 3 
digit no. assigned to you in blackboard.

You will lose 5 point if you do not following this naming convention. 

2. We do not accept any late submissions.
3. If you encounter any difficulties, and but you can upload your submission
   within an hour after the due date, please state the reason below:

State the reason(s) for late submission below (if needed):


4. If you cannot upload your submission within an hour after the due date
   because of a valid reason (eg. network/power outage etc.)  contact the
   grader at 

   ymfarhat@syr.edu 

   when email is available. Your grader will not grade your work but you may 
   receive an exemption.

--------------------------------------------------------------------------------

Note:

1. To answer the programming questions, add the haskell code according to the
requirement. DO NOT FORGET to add the > symbol below each line in your code.

2. Use the given Set.hs file (this differs from the standard one we once used
   in our lectures), save it in the same directory when you are working on this 
   homework.

--------------------------------------------------------------------------------

Problem 1 (Total: 30 point) Executable specifications for the Set datatype


To understand programs we must know what it is supposed to do. That is, we must 
know its specification. Thus a rigorous, unambiguous specification is an 
invaluable tool for reasoning about programs.

In functional programming, an executable specification is an automated test 
that verifies if a program (ie. functions) meet its specification. 

In this question, you are asked to write QuickCheck properties. We consider 
these properties are executable specification for the Set data type. 

You may assume that the functions makeSet, eqSet are correctly implemented.


----------
a. (10 point)  Write a QuickCheck property 

> prop_union_Commutative :: Ord a => [a] -> [a] -> Bool

so that it verify if the union operation for sets is commutative. 

In addition, put the results generated by QuickCheck after the code.

If the property fails, provide a counterexample for the case when the 
underlying type a is Int.


*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> prop_union_Commutative xs ys = ((union (makeSet xs) (makeSet ys)) == (union (makeSet ys) (makeSet xs)))

*Main> quickCheck prop_union_Commutative 
+++ OK, passed 100 tests.

--------------------------------------------------------------------------------


b. (10 point) Write a QuickCheck property 

> prop_union_Associative :: Ord a => [a] -> [a] -> [a] -> Bool

so that it verify if the union operation for sets is associative.

In addition, put the results generated by QuickCheck after the code.

If the property fails, provide a counterexample for the case when the 
underlying type a is Int.

*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> prop_union_Associative x y z= union (makeSet x) (union (makeSet y) (makeSet z)) == union (union (makeSet x) (makeSet y)) (makeSet z)

*Main> quickCheck prop_union_Associative 
+++ OK, passed 100 tests.

--------------------------------------------------------------------------------

c. (10 point) Write a QuickCheck property

> prop_diff_Associative :: Ord a => [a] -> [a] -> [a] -> Bool

so that it verify if the diff operation for sets is associative.

In addition, put the results generated by QuickCheck after the code.

If the property fails, provide a counterexample for the case when the 
underlying type a is Int.

*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> prop_diff_Associative x y z = diff (makeSet x) (diff(makeSet y) (makeSet z)) == diff (diff (makeSet x) (makeSet y)) (makeSet z)

*Main> quickCheck prop_diff_Associative 
*** Failed! Falsified (after 2 tests):
[()]
[]
[()]

*Main> showSet (show) (a)
"{ 1 2 3 4 5 }"
*Main> showSet (show) b
"{ }"
*Main> showSet (show) c
"{ 3 4 5 6 7 8 9 }"
*Main> showSet (show) (diff a (diff b c))
"{ 1 2 3 4 5 }"
*Main> showSet (show) (diff (diff a b) c)
"{ 1 2 }"

--------------------------------------------------------------------------------

Problem 2 (Total: 30 point)  Manipulate principal expressions 

Consider the following definition of the principal expression (ACST, page 18) 

Princ ::= PName / Princ & Princ / Princ | Princ  ... (*)

In this problem, we implement a data type Prin to represent a principal 
expression as follows:

> type PName = String

> data Prin = Name PName | Together Prin Prin | Quote Prin Prin  -- (**)
>              deriving (Eq, Show)


where each rule in (**) corresponds to the rule in (*) according to the 
same order.


a. (10 point)  Suppose that there are three principals named

You, Me, Him

Following the Haskell definition (ie. (**)) to create two prinicpal expressions 
pexp1 , pexp2 (each of type Prin) which represent

(You & Me)  (as in the definition in ACST) 

(You | (Me & Him))  (as in the definition of ACST) 

respectively.

*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> y :: Prin
> y = Name "You"
> m :: Prin
> m = Name "Me"
> h :: Prin
> h = Name "Him"
> pexp1 :: Prin 
> pexp1 = Together y m
> pexp2 :: Prin 
> pexp2 = Quote y (Together m h)

--------------------------------------------------------------------------------

b. (20 point)  Write a function isSimple, in Haskell, it will take 
a list lst (of type [(Prin,a)]) as input, return true if the first
coordinate of each tuple in lst is a simple principal. Otherwise
it will return False.

> test2b1 :: Bool
> test2b1 = isSimple [(y,1),(m,2),(h,3)]

> test2b2 :: Bool
> test2b2 = isSimple [((Quote y m) , 1) ,(m,2), (h,3)]

We have

*Main> test2b1
True
*Main> test2b2
False

*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> isSimple :: [(Prin, a)] -> Bool
> isSimple [] = True
> isSimple lst = ([prin|(prin, n) <- lst] == [(Name pr)|(Name pr, n) <- lst])

> test2b1a :: Bool
> test2b1a = isSimple [(pexp1,1),(m,2),(h,3)]

*Main> test2b1a
False

--------------------------------------------------------------------------------

Problem 3 (Total = 55 point) Manipulate ACL formulas for model checking

We assume that the principal expression datatype is defined as in Problem 2.
We continue to define the Access control formula via the following declaration:

> data Form  = Var Char
>            | Not   Form
>            | Or    Form Form
>            | And   Form Form
>            | Imply Form Form
>            | Equiv Form Form
>            | Says  Prin Form
>            | Contr Prin Form
>            | For   Prin Prin
>              deriving Show

In addition, propositional variables are of type Char:

> type PropVar = Char

a.  (20 point)   Write a function is_ACL_prin, which will take

    -- a list of simple principals plst (of type [PName])
    -- a principle expression pr

    as input, verify if each simple principal shown in
    the principal expression pr is in the list plst.


For example:

> princLst :: [PName]
> princLst = ["Al","Marcy"]

> eg3a :: Prin
> eg3a=  Name "Marcy" 

% > testEg3a :: Bool
% > testEg3a =  is_ACL_prin princLst eg3a

You will get:

*Main> testEg3a
True

*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> is_ACL_prin :: [PName] -> Prin -> Bool
> is_ACL_prin [] pr = False
> is_ACL_prin pns (Name n) = elem (Name n) [(Name pn)| pn <- pns]
> is_ACL_prin pns (Together p1 p2) = (is_ACL_prin pns p1) && (is_ACL_prin pns p2)
> is_ACL_prin pns (Quote p1 p2) = (is_ACL_prin pns p1) && (is_ACL_prin pns p2)

> testEg3a :: Bool
> testEg3a =  is_ACL_prin princLst eg3a

--------------------------------------------------------------------------------

b. (25 point) 

First, note that when we specify a specific Kripke model M = (W, I, J), we need to 
also state 

   -- a list of simple principals (of type [PName]) which are included in the model 
   -- a list of propositional variables (of type [PropVar]) which are included in 
      the model 


By using the function ACL_prin (part a) or otherwise, write a Boolean function 
is_ACL_Form,  which will take 

    -- a  list of simple principals plst (of type [PName])
    -- a  list of propositional variables proplst (of type [PropVar])  
    -- an ACL formula (of type Form) 

as input, verify if a formula is a valid ACL formula for the model M, where 

    -- each simple principal in M is a member of plst, and 
    -- each propositional variable in M is a member of proplst.
 

*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> is_ACL_Form :: [PName] -> [PropVar] -> Form -> Bool
> is_ACL_Form pns [] fm = False
> is_ACL_Form [] pvs fm = False
> is_ACL_Form pns pvs (Var ch) = elem ch pvs
> is_ACL_Form pns pvs (Not fm) = is_ACL_Form pns pvs fm
> is_ACL_Form pns pvs (Or f1 f2) = (is_ACL_Form pns pvs f1) && (is_ACL_Form pns pvs f2)
> is_ACL_Form pns pvs (And f1 f2) = (is_ACL_Form pns pvs f1) && (is_ACL_Form pns pvs f2)
> is_ACL_Form pns pvs (Imply f1 f2) = (is_ACL_Form pns pvs f1) && (is_ACL_Form pns pvs f2)
> is_ACL_Form pns pvs (Equiv f1 f2) = (is_ACL_Form pns pvs f1) && (is_ACL_Form pns pvs f2)
> is_ACL_Form pns pvs (Says pr fm) = (is_ACL_prin pns pr) && (is_ACL_Form pns pvs fm)
> is_ACL_Form pns pvs (Contr pr fm) = (is_ACL_prin pns pr) && (is_ACL_Form pns pvs fm)
> is_ACL_Form pns pvs (For pr1 pr2) = (is_ACL_prin pns pr1) && (is_ACL_prin pns pr2)

--------------------------------------------------------------------------------

c. (10 point)  Create two formulas f1, f2 (ACL formulas), in Haskell,  based on 
   the model given in ACST, example 2.8 as test cases. The formula f1 is an ACL 
   formula for the model but f2 is a ACL formula (of type Form) which is not 
   a formula for the model.

   Show the two fomulas and the test results in the space provided below.


*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

Alice says (q implies (r conjuncts s))

> pnlst :: [PName]
> pnlst = ["Alice", "Bob"]
> pvlst :: [PropVar]
> pvlst = ['q', 'r', 's']
> f1 :: Form
> f1 = Says (Name "Alice") (Imply (Var 'q') (Var 's'))
> f2 :: Form
> f2 = Says (Name (head princLst)) (Imply (Var 'q') (Var 's'))

ghci> is_ACL_Form pnlst pvlst f1
True
ghci> is_ACL_Form pnlst pvlst f2
False

--------------------------------------------------------------------------------

Problem 4 (Total: 20 point) Higher order functions

a. Define a higher order function merge 

> merge :: (a -> a -> Bool) -> [a] -> [a] -> [a] 

so that 

merge cmp xs ys

will merge xs ys (both sorted with respect to the comparison function cmp)
to return a single sorted list (sorted with respect to the comparison  function 
cmp). For example,

*Main> merge (<=) [1,3,5,7] [2,4,6,8]
[1,2,3,4,5,6,7,8]
*Main> merge (>=) [7,5,3,1] [8,6,4,2]
[8,7,6,5,4,3,2,1]
 


*** Put your answer below. For codes, DO NOT FORGET to add the > symbol.

> merge f [] ys = ys
> merge f xs [] = xs
> merge f (x:xs) (y:ys) 
>     | f x y = [x] ++ [y] ++ merge f xs ys
>     | otherwise = [y] ++ [x] ++ merge f xs ys

--------------------------------------------------------------------------------

